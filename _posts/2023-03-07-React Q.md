---
layout: single
title: "React 2주차 Quiz"
categories: React
# tag:
toc: true
toc_label: "목차"
toc_sticky: true
---

1. Q1. 컴포넌트 A는 리덕스 스토어를 구독하고 있습니다. 리덕스에 저장된 데이터가 변경되었을 때(A가 구독 중인 값이 변경되었다고 가정합니다. 어떤 과정을 거쳐 컴포넌트 A가 변경된 값을 가져올 수 있는 지 흐름을 그려볼까요? (메모장, 사진 등)

2. Q2. 리액트 개발 시, 렌더링 최적화 방법에 이용할 수 있는 다음 세 가지의 특징과 차별점을 각각 말씀해주세요.

   1. React.memo
   2. useCallback
   3. useMemo

      1. React.memo

   - 특징: React.memo는 함수형 컴포넌트의 렌더링을 최적화하는 방법 중 하나이다.
     이전에 렌더링한 결과를 **메모이제이션(Memoization)하여**, 같은 props가 전달될 경우 렌더링을 다시 하지 않고 **이전에 렌더링한 결과를 재사용**한다.
   - 차별점: React.memo는 props가 변경되지 않으면 렌더링을 다시 하지 않으므로, **렌더링이 자주 발생하는 컴포넌트의 경우 사용**하면 성능 향상에 큰 도움이 된다.

     2. useCallback

   - 특징: useCallback은 함수형 컴포넌트 **내부에서 생성된 함수를 메모이제이션**하여, 같은 함수가 중복 생성되지 않도록 한다.
     **이전에 생성한 함수를 재사용**함으로써, 불필요한 렌더링을 방지하고 성능을 최적화할 수 있다.
   - 차별점: useCallback은 같은 함수가 중복 생성되는 것을 방지하므로, 자주 변경되지 않는 함수나 **자식 컴포넌트에 props로 전달되는 함수**에 사용하면 성능 향상에 큰 도움이 된다.

     3. useMemo

   - 특징: useMemo는 계산 비용이 높은(Paint) 함수나 연산 결과를 메모이제이션하여, **같은 계산이 중복되지 않도록 한다.**
     이전에 계산한 결과를 재사용함으로써, 불필요한 계산을 방지하고 성능을 최적화할 수 있습니다.
   - 차별점: useMemo는 계산 비용이 높은 함수나 연산 결과를 메모이제이션하여 사용하므로, 매번 렌더링될 때마다 계산이 수행되는 것을 방지하고 성능을 향상시킬 수 있다. 따라서, **특히 계산이 복잡한 컴포넌트에서 사용하면 성능 향상에 큰 도움이 된다.**

3. Q3. <form>을 사용할 때, <button type="submit">을 함께 사용하면 리덕스 데이터가 초기화 되는데, 왜 초기화 되는 지 생각해봅시다.

<form> 요소에는 사용자가 입력을 서버로 전송할 때 사용되는 데이터가 포함되는데,
기본적으로 **<form>요소에서 submit 이벤트가 발생**하면 브라우저는 <form> 요소 안의 입력
요소의 값을 서버로 전송한다. **이때 브라우저는 새로운 페이지를 로드**하게 되므로
리덕스 스토어의 상태도 함께 초기화 된다.

즉, 제출(submit) 이벤트가 발생하면, 페이지가 다시 로드 되기 때문이다.

4.  Q4. 새로고침 시에도 리덕스 내의 데이터를 유지하려면 어떤 방법을 써야할까요?

        1. <button> 태그의 type 속성을 ‘button’으로 설정하여 **클릭 이벤트만 발생시킨다.**

        2. 이벤트 핸들러에서 preventDefault() 메서드를 호출하여, 기본 제출(submit) 이벤트를 막는다.
            > 이벤트 객체의 메서드 중 하나로 이벤트의 **기본 동작을 막는 역할**을 한다
            <form> 요소의 기본적인 동작을 막되, 입력된 데이터를 가지고 사용자가 지정한 작업을 수행 할 수 있다.

        3. **onSubmit() 이벤트를 사용**하여 <form> 요소가 제출될 때의 동작을 컨드롤 한다.

        > onSubmit 이벤트 핸들러 함수에서 이벤트 객체의 preventDefault() 메서드를 호출하여,
        기본 제출 이벤트를 막을 수 있고,(2번과 유사) 이후, JavaScript 코드에서 필요한 동작을 수행하거나, React 이벤트를 이용하여 컴포넌트의 상태를 변경하고, 서버로 데이터를 전송하는 등의 작업을 수행할 수 있다.(2번의 상위호환으로 판단됨)

5.  Q5. React Hook 중 useRef는 어느 경우 사용하게 되나요? 두 가지 이상 적어봅시다.

    1. DOM 요소의 포커스 관리

    - useRef를 사용하여 DOM 요소에 ref 속성을 설정하면, **해당 요소를 컴포넌트에서 직접 참조할 수 있다.** 이를 이용하여, 특정 조건에 따라 **DOM 요소에 포커스**를 줄 수 있습다.

    예를 들어, 검색 창이 열릴 때 자동으로 포커스를 설정하거나, 스크롤이 발생할 때 이전에 선택한 DOM 요소에 포커스를 유지하는 등의 작업을 수행할 수 있다.

    2. 이전 상태와 비교

    - useRef를 이용하여 이전 상태를 저장하고, **이전 상태와 현재 상태를 비교**하는 등의 작업을 수행할 수 있다.

    예를 들어, 컴포넌트가 렌더링될 때마다 이전 상태와 현재 상태를 비교하여, **변경된 상태에 대한 작업을 수행**하거나, **변경된 상태를 다시 저장**하는 등의 작업을 수행할 수 있다.

    3. 외부 라이브러리와의 연동

    - **외부 라이브러리와의 연동에 필요한 DOM 요소를 참조할 때 useRef를 사용**할 수 있다.

    예를 들어, D3.js, Chart.js 등의 데이터 시각화 라이브러리와 연동할 때, useRef를 사용하여 그래프를 그릴 DOM 요소를 참조할 수 있다.(????????)

    4. setInterval, setTimeout 등의 함수와의 연동

    - setInterval, setTimeout 등의 함수와 함께 사용할 때 useRef를 사용할 수 있다.
      useRef를 사용하여 이전 값과 현재 값을 비교하여, 변경된 값에 대한 작업을 수행하거나, 변경된 값을 저장하는 등의 작업을 수행할 수 있다.

    5. 컴포넌트 내부에서 값의 변경을 추적

    - useRef를 사용하여 컴포넌트 내부에서 값의 변경을 추적할 수 있다.

    예를 들어, 컴포넌트가 **렌더링될 때마다 값이 변경되는 경우**, useRef를 사용하여 이전 값과 현재 값을 비교하여, 변경된 값에 대한 작업을 수행할 수 있다.
    또한, useEffect와 같은 Hook과 함께 사용하여, 컴포넌트의 상태 변화를 추적할 수도 있다.

6.  Q6. 리액트가 왜 Virtual DOM을 통해 컴포넌트를 그리는 것일까요? Virtual DOM을 사용할 때 왜 더 효율적인지에 대해 설명해주세요.

    1. 성능 최적화

    - Virtual DOM은 이전 상태와 현재 상태의 차이를 계산하여 **변경된 부분만 실제 DOM에 반영한다.** 이를 이용하여, 리액트는 최소한의 DOM 조작으로도 컴포넌트를 업데이트할 수 있다.
      따라서, 성능이 더 효율적으로 개선됩니다.

    2. 모바일 환경 지원

    - 모바일 환경에서는 CPU나 메모리 등의 자원이 제한적인데,
      이러한 환경에서는 성능 최적화가 더욱 중요하며,
      Virtual DOM은 최적화를 통해 **모바일 환경에서도 높은 성능을 보장할 수 있다.**

    3. 브라우저 호환성

    - 브라우저마다 DOM 조작 방식이 다르기 때문에, 직접적인 DOM 조작이 크로스 브라우징 문제를 일으킬 수 있다.
      그러나, Virtual DOM은 브라우저 호환성 문제를 해결할 수 있다.
      **Virtual DOM은 브라우저마다 동일한 방식으로 동작**하기 때문에, 크로스 브라우징 문제가 발생하지 않는다.

    4. 유지보수성

    - **직접적인 DOM 조작은 코드의 복잡성을 증가시킬 수 있다.**
      그러나, Virtual DOM은 코드의 복잡성을 줄여준다.
      Virtual DOM을 사용하면, **컴포넌트가 독립적으로 동작**하기 때문에, 유지보수가 더욱 용이해진다.

7.  Q7. 비동기 프로그래밍이란 무엇인가요? 또한 콜백지옥이 발생할 때의 문제점은 무엇이며 이를 극복하기 위해 대안으로 나온 방법 2가지를 설명해주세요.
    비동기 프래그래밍이란?

        - 비동기 프로그래밍이란, 작업이 순차적으로 진행되는 동기적 프로그래밍 방식과 달리, 작업이 **병렬적으로 실행**되는 프로그래밍 방식입이다.
        비동기 프로그래밍은 **특정 작업이 끝나기를 기다리지 않고**,
        다음 작업을 실행하는 방식으로 동작한다.

    콜백지옥의 문제점

        - 비동기적으로 처리하다 보면, 여러 개의 작업이 동시에 실행될 수 있는데,
        이러한 작업들의 **결과를 제어하는 것이 어렵고 복잡**해지며, 코드의 가독성 또한 떨어뜨려
        **유지보수를 어렵게** 만듭니다.

    콜백지옥의 해결법

        - Promise
            - 비동기 작업의 결과를 처리하는 새로운 방법으로 비동기 작업이 완료되면 결과를 처리할 수 있는 객체를 반환한다.
            이를 통해 콜백 함수를 연속적으로 호출하는 것이 아닌,
            **Promise 객체의 then() 메서드를 이용하여** 비동기 작업의 결과를 처리할 수 있다.

            Promise는 콜백 지옥을 해결하고, 비동기 코드를 더 직관적으로
            작성할 수 있게 해주지만, then() **메서드를 연속해서 호출하면서 중첩될 수 있고
            이 또한 콜백지옥으로 이어질 수 있으며,**
            비동기 작업이 실패할 경우 오류 처리 방법이 일관성이 없어 디버깅이 힘든 점,
            Promise를 중단하거나 진행 상황을 중간에 알릴 수 없다는 점 등의 문제가 있어

            이를 보완하고자 아래 새로운 문법인 async/await가 추가 되었다.
        - async/await
            - 2017년(ES8)에 추가된 문법으로 Promise의 문제점을 개선하며, 코드의 가독성 유지 보수성을 높이는데 도움을 줍니다.
            async 함수는 Promise를 반환하고 await 키워드를 사용하여 비동기 작업이 완료될 때 까지 기다린 후 결과를 처리 할 수 있다.
            **즉, async/await 는 Promise와 함께 사용되며, Promise를 좀 더 간결하고 직관적으로 작성할 수 있게 도와준다.**

금주의 키워드

Styled-Components

React 애플리케이션에서 사용할 수 있는  
CSS-in-JS 라이브러리 중 하나입니다.  
CSS-in-JS는 컴포넌트와 함께 CSS 스타일을 작성하는 방식으로,  
스타일을 더욱 모듈화하고  
컴포넌트와 스타일을 하나의 파일에서 관리할 수 있며,  
className의 충돌을 피하고,  
재사용 가능한 스타일 컴포넌트를 만들 수 있습니다.

또한 컴포넌트 내부에서 CSS를 작성할 때,  
key : value 형식으로 작성하는 것이 어색하고  
자동완성 태그도 제시되지 않아  
약간 불편했지만 Styled-Components를 사용하여  
본래 CSS 문법으로 작성이 가능합니다.

간단하게 요약하면, CSS-in-JS는  
CSS 코드를 JS 코드로 작성하고,  
이것으로 컴포넌트를 꾸민다로 정리할 수 있겠습니다.

또한 높고, 꾸준한 npm trends 점유율로  
신뢰성이 높은 패키지라고 생각 됩니다.
